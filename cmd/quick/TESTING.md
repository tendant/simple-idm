# Testing Guide for cmd/quick

This guide explains how to test the refactored cmd/quick service.

## Prerequisites

1. **PostgreSQL Database**
   ```bash
   # Create database
   createdb idm_db

   # Or using psql
   psql -U postgres -c "CREATE DATABASE idm_db;"
   ```

2. **Run Migrations**
   ```bash
   # From project root
   make migration-up

   # Or manually with goose
   cd migrations/idm
   goose postgres "postgres://idm:pwd@localhost:5432/idm_db?sslmode=disable" up
   ```

3. **Environment Configuration**
   ```bash
   # Copy example config
   cp .env.example .env

   # Edit .env with your settings (optional - defaults work for local dev)
   ```

## Manual Testing

### 1. Test Database Connectivity

```bash
# Test database connection
psql -U idm -d idm_db -c "SELECT 1;"

# Verify migrations ran
psql -U idm -d idm_db -c "\dt"
# Should see tables: users, roles, user_roles, logins, etc.
```

### 2. Test Service Startup

```bash
# Build and run
go build -o quick main.go
./quick

# Expected output:
# - RSA key bootstrap (generated or loaded)
# - Database connection success
# - Admin bootstrap (roles + user creation)
# - OAuth2 clients loaded from environment
# - Service ready message
```

**Check for:**
- âœ… RSA key file created: `jwt-private.pem`
- âœ… Admin bootstrap output showing roles created
- âœ… Admin user credentials displayed (SAVE THEM!)
- âœ… No errors in logs
- âœ… Server listening on port 4000

### 3. Test RSA Key Bootstrap

**First run (key generation):**
```bash
# Remove existing key
rm -f jwt-private.pem

# Run service
./quick

# Expected:
# âœ¨ Generated new RSA key: /path/to/jwt-private.pem (Key ID: quick-idm-xxxx, 2048 bits)
```

**Second run (key loading):**
```bash
# Run service again
./quick

# Expected:
# âœ“ Loaded RSA key: /path/to/jwt-private.pem (Key ID: quick-idm-xxxx, 2048 bits)
# (Same Key ID as before - consistent!)
```

**Verify key file:**
```bash
# Check permissions
ls -la jwt-private.pem
# Should show: -rw------- (0600)

# Check content
head -1 jwt-private.pem
# Should show: -----BEGIN RSA PRIVATE KEY-----
```

### 4. Test Admin Role and User Bootstrap

**First run (bootstrap):**
```bash
# Clear database
psql -U idm -d idm_db -c "TRUNCATE users, roles, user_roles, logins CASCADE;"

# Run service
./quick

# Expected output:
# ================================================================================
# ðŸš€ ADMIN BOOTSTRAP COMPLETED
# ================================================================================
#
# ðŸ“‹ Admin Roles:
# --------------------------------------------------------------------------------
#   1. admin (PRIMARY - assigned to admin user)
#      ID: <uuid>
#      Status: âœ¨ Created
#
#   2. superadmin
#      ID: <uuid>
#      Status: âœ¨ Created
#
# ðŸ‘¤ Admin User:
# --------------------------------------------------------------------------------
#   Username:  super
#   Email:     super@example.com
#   User ID:   <uuid>
#   Login ID:  <uuid>
#   Role:      admin
#   Password:  <auto-generated-password>  â† SAVE THIS!
#
# âš ï¸  SECURITY REMINDERS:
# --------------------------------------------------------------------------------
#   â€¢ THIS PASSWORD WILL NOT BE DISPLAYED AGAIN - SAVE IT NOW!
#   ...
```

**Second run (skip bootstrap):**
```bash
# Run service again
./quick

# Expected:
# "Users already exist - skipping admin bootstrap"
# (No admin creation output)
```

**Verify database:**
```bash
# Check roles created
psql -U idm -d idm_db -c "SELECT role_name FROM roles;"
# Should show: admin, superadmin

# Check user created
psql -U idm -d idm_db -c "SELECT username, email FROM users;"
# Should show: super, super@example.com
```

**Test with custom admin credentials:**
```bash
# Set environment variables
export ADMIN_USERNAME=myadmin
export ADMIN_EMAIL=admin@mycompany.com
export ADMIN_PASSWORD=MySecurePass123!

# Clear database
psql -U idm -d idm_db -c "TRUNCATE users, roles, user_roles, logins CASCADE;"

# Run service
./quick

# Expected:
# Username: myadmin
# Email: admin@mycompany.com
# Password: (configured via ADMIN_PASSWORD environment variable)
```

### 5. Test Custom Admin Roles

```bash
# Configure custom admin roles
export ADMIN_ROLE_NAMES=administrator,root,superuser

# Clear database
psql -U idm -d idm_db -c "TRUNCATE users, roles, user_roles, logins CASCADE;"

# Run service
./quick

# Expected:
# ðŸ“‹ Admin Roles:
#   1. administrator (PRIMARY - assigned to admin user)
#      Status: âœ¨ Created
#   2. root
#      Status: âœ¨ Created
#   3. superuser
#      Status: âœ¨ Created
```

### 6. Test OAuth2 Client Loading

**Configure OAuth2 clients:**
```bash
# Edit .env
cat >> .env << 'EOF'
OAUTH2_CLIENTS=webapp,mobileapp
OAUTH2_CLIENT_WEBAPP_ID=my-web-client
OAUTH2_CLIENT_WEBAPP_SECRET=web-secret-123
OAUTH2_CLIENT_WEBAPP_REDIRECT_URIS=http://localhost:3000/callback
OAUTH2_CLIENT_WEBAPP_SCOPES=openid profile email
OAUTH2_CLIENT_MOBILEAPP_ID=my-mobile-client
OAUTH2_CLIENT_MOBILEAPP_SECRET=mobile-secret-456
OAUTH2_CLIENT_MOBILEAPP_REDIRECT_URIS=myapp://auth/callback
EOF

# Run service
./quick

# Expected log:
# "OAuth2 clients loaded from environment variables"
```

**Verify OAuth2 clients loaded:**
```bash
# The clients are in-memory, not in database
# Test via API (see API Testing section below)
```

### 7. Test API Endpoints

**Health Check:**
```bash
curl http://localhost:4000/healthz
# Expected: {"status":"ok"}

curl http://localhost:4000/healthz/ready
# Expected: {"status":"ready"}
```

**OIDC Discovery:**
```bash
curl http://localhost:4000/.well-known/openid-configuration | jq
# Expected: JSON with issuer, authorization_endpoint, token_endpoint, etc.

curl http://localhost:4000/.well-known/jwks.json | jq
# Expected: JSON with public keys
```

**Login (Get JWT Token):**
```bash
# Use the admin credentials from bootstrap
curl -X POST http://localhost:4000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "username": "super",
    "password": "YOUR_ADMIN_PASSWORD_HERE"
  }'

# Expected: JSON with access_token, refresh_token
# Save the access_token for subsequent requests
export TOKEN="<access_token_from_response>"
```

**Get Current User Info:**
```bash
curl http://localhost:4000/me \
  -H "Authorization: Bearer $TOKEN" | jq

# Expected: User info JSON with roles
```

**List Roles (Admin Only):**
```bash
curl http://localhost:4000/api/roles \
  -H "Authorization: Bearer $TOKEN" | jq

# Expected: Array of roles (admin, superadmin)
```

**List Users (Admin Only):**
```bash
curl http://localhost:4000/api/users \
  -H "Authorization: Bearer $TOKEN" | jq

# Expected: Array with admin user
```

## Automated Testing

### Unit Tests

Run unit tests for individual packages:

```bash
# Test bootstrap package
go test -v ./pkg/bootstrap/...

# Test config package
go test -v ./pkg/config/...

# Test all packages
go test -v ./...
```

### Integration Tests

Create integration test script:

```bash
# Create test script
cat > test_integration.sh << 'EOF'
#!/bin/bash
set -e

echo "=== Integration Test Suite ==="

# 1. Setup test database
echo "1. Setting up test database..."
dropdb --if-exists idm_test_db
createdb idm_test_db
export IDM_PG_DATABASE=idm_test_db

# 2. Run migrations
echo "2. Running migrations..."
cd migrations/idm
goose postgres "postgres://idm:pwd@localhost:5432/idm_test_db?sslmode=disable" up
cd ../..

# 3. Build service
echo "3. Building service..."
go build -o quick_test main.go

# 4. Start service in background
echo "4. Starting service..."
./quick_test &
SERVICE_PID=$!
sleep 3

# 5. Run tests
echo "5. Running API tests..."

# Health check
curl -f http://localhost:4000/healthz || exit 1
echo "âœ“ Health check passed"

# OIDC discovery
curl -f http://localhost:4000/.well-known/openid-configuration > /dev/null || exit 1
echo "âœ“ OIDC discovery passed"

# Login test
RESPONSE=$(curl -s -X POST http://localhost:4000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"super","password":"test123"}')

if echo "$RESPONSE" | grep -q "access_token"; then
  echo "âœ“ Login test passed"
else
  echo "âœ— Login test failed"
  exit 1
fi

# 6. Cleanup
echo "6. Cleaning up..."
kill $SERVICE_PID
rm -f quick_test jwt-private.pem

echo "=== All tests passed! ==="
EOF

chmod +x test_integration.sh
./test_integration.sh
```

## Troubleshooting

### Database Connection Errors

```bash
# Check PostgreSQL is running
pg_isready

# Check connection parameters
psql -U idm -d idm_db -c "SELECT version();"

# Check .env configuration
cat .env | grep IDM_PG
```

### RSA Key Errors

```bash
# Remove corrupted key
rm -f jwt-private.pem

# Check file permissions
chmod 600 jwt-private.pem
```

### Admin Bootstrap Not Running

```bash
# Check if users exist
psql -U idm -d idm_db -c "SELECT COUNT(*) FROM users;"

# Clear users to trigger bootstrap
psql -U idm -d idm_db -c "TRUNCATE users, logins CASCADE;"
```

### OAuth2 Client Not Loading

```bash
# Check environment variables
env | grep OAUTH2

# Check .env file loaded
cat .env | grep OAUTH2

# Verify format
# OAUTH2_CLIENTS must be comma-separated list
# Each client needs: <NAME>_ID, <NAME>_SECRET, <NAME>_REDIRECT_URIS
```

## Test Checklist

- [ ] Database migrations run successfully
- [ ] Service starts without errors
- [ ] RSA key generates on first run
- [ ] RSA key loads on subsequent runs (same Key ID)
- [ ] Admin roles created (admin, superadmin by default)
- [ ] Admin user created with credentials displayed
- [ ] Custom admin roles work (via ADMIN_ROLE_NAMES)
- [ ] Custom admin credentials work (via ADMIN_USERNAME, etc.)
- [ ] OAuth2 clients load from environment
- [ ] Health endpoints return 200
- [ ] OIDC discovery endpoints work
- [ ] JWKS endpoint returns public keys
- [ ] Login returns JWT tokens
- [ ] Protected endpoints require authentication
- [ ] Admin endpoints check for admin role
- [ ] Service can be stopped and restarted cleanly

## Success Criteria

âœ… **All manual tests pass**
âœ… **Integration test script passes**
âœ… **No errors in service logs**
âœ… **All API endpoints respond correctly**
âœ… **Authentication and authorization work**
âœ… **Database state is correct**

## Next Steps

After testing cmd/quick, you can:
1. Apply same refactoring to cmd/loginv2
2. Apply same refactoring to cmd/login
3. Create shared bootstrap package for all services
4. Add more automated tests
